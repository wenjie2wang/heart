##
## R package reda by Wenjie Wang, Haoda Fu, and Jun Yan
## Copyright (C) 2015-2019
##
## This file is part of the R package reda.
##
## The R package reda is free software: You can redistribute it and/or
## modify it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or any later
## version (at your option). See the GNU General Public License at
## <https://www.gnu.org/licenses/> for details.
##
## The R package reda is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
##


## collation after class.R
##' @include class.R
NULL


##' Show an object.
##'
##' S4 class methods that display objects produced from this package (similar to
##' S3 class \code{print} methods).
##'
##' @param object An object used to dispatch a method.
##' @name show-method
##' @importFrom methods show
NULL


##' @rdname show-method
##' @aliases show,Recur-method
##' @export
setMethod(f = "show", signature = "Recur",
          definition = function(object) {
              ## determine the number of significant digits
              charNum <- unique(as.character(
                  object@.Data[, c("time1", "time2")]
              ))
              tmpList <- strsplit(charNum, "\\.")
              sigMax <- min(
                  max(sapply(tmpList, function(a) {
                      if (length(a) > 1)
                          return(nchar(a[2L]))
                      0
                  })),
                  max(3, getOption("digits") - 3)
              )
              fmt <- sprintf("(%s.%df, %s.%df%s]",
                             "%", sigMax, "%", sigMax, "%s")
              sorted_dat <- object@.Data[object@ord, , drop = FALSE]
              ## create a character vector representing the recurrent events
              char_rec <- tapply(
                  seq_along(object@ord), object@ID[object@ord],
                  function(idx) {
                      sub_time1 <- sorted_dat[idx, "time1"]
                      sub_time2 <- sorted_dat[idx, "time2"]
                      sub_is_censored <- sorted_dat[idx, "event"] == 0
                      sub_terminal <- max(sorted_dat[idx, "terminal"],
                                          na.rm = TRUE)
                      sub_end <- ifelse(sub_terminal > 0, "*", "+")
                      sub_sign <- ifelse(sub_is_censored, "+", "")
                      sub_sign[length(idx)] <- sub_end
                      out <- sprintf(fmt, sub_time1,
                                     sub_time2, sub_sign)
                      char_id <- sprintf("%s:", object@ID[idx[1L]])
                      paste(char_id, paste(out, collapse = ", "))
                  })
              ## avoid printing long strings
              maxPrint <- 3
              rights <- lapply(strsplit(char_rec, ''), function(x) which(x == ']'))
              if (any(lapply(rights, length) > maxPrint)) {
                  toTruc <- lapply(rights, length) > maxPrint
                  char_rec[which(toTruc)] <- sapply(which(toTruc), function(x) {
                      txt <- char_rec[[x]]
                      paste(substr(txt, 0, rights[[x]][maxPrint - 1]),
                            substr(txt, tail(rights[[x]], 2)[1] + 1, tail(rights[[x]], 1)),
                            sep = ", ...")    
                  })
              }
              char_rec <- unname(as.character(char_rec))
              print(char_rec, quote = FALSE)
              invisible(object)
          })


##' @rdname show-method
##' @aliases show,rateReg-method
##' @export
setMethod(f = "show", signature = "rateReg",
          definition = function(object) {
              beta <- object@estimates$beta[, "coef"]
              names(beta) <- row.names(object@estimates$beta)
              theta <- object@estimates$theta[, "parameter"]
              names(theta) <- NULL
              alpha <- object@estimates$alpha[, "coef"]
              names(alpha) <- row.names(object@estimates$alpha)
              cat("Call: \n")
              print(object@call)
              if (length(beta) > 0) {
                  cat("\nCoefficients of covariates: \n")
                  print(beta)
              }
              cat("\nFrailty parameter: ", theta, "\n")
              knots <- object@spline$knots
              Boundary.knots <- object@spline$Boundary.knots
              if (length(knots)) {
                  cat("\nInternal knots: \n")
                  cat(knots, sep = ", ", fill = TRUE)
              }
              cat("\nBoundary knots: \n")
              cat(Boundary.knots, sep = ", ", fill = TRUE)
              if (object@spline$degree) {
                  cat("\nCoefficients of spline bases:\n")
                  print(alpha)
              } else {
                  cat("\nCoefficients of pieces:\n")
                  print(alpha)
              }
              ## invisible return
              invisible(object)
          })


##' @rdname show-method
##' @aliases show,summaryRateReg-method
##' @importFrom stats printCoefmat
##' @export
setMethod(f = "show", signature = "summary.rateReg",
          definition = function(object) {
              if (attr(object@call, "show")) {
                  Call <- object@call
                  attr(Call, "show") <- NULL
                  cat("Call: \n")
                  print(Call)
              }
              if (nrow(object@covarCoef) > 0) {
                  cat("\nCoefficients of covariates: \n")
                  printCoefmat(object@covarCoef)
              }
              cat("\nParameter of frailty: \n")
              print(object@frailtyPar)
              ## on knots
              if (attr(object@knots, "show")) {
                  if (length(object@knots)) {
                      cat("\nInternal knots: \n")
                      cat(object@knots, sep = ", ", fill = TRUE)
                  }
                  cat("\nBoundary knots:\n")
                  cat(object@Boundary.knots, sep = ", ", fill = TRUE)
              }
              ## baseline rate function
              cat("\nDegree of spline bases:", object@degree, "\n")
              cat("\nCoefficients of spline bases:\n")
              printCoefmat(object@baseRateCoef)
              cat("\nLoglikelihood: ", object@logL, "\n")
              ## invisible return
              invisible(object)
          })


##' @rdname show-method
##' @aliases show,mcf.formula-method
##' @export
setMethod(f = "show", signature = "mcf.formula",
          definition = function(object) {
              cat("Formula:\n")
              print(object@formula)
              cat("\nMCF:\n")
              print(object@MCF)
              ## invisible return
              invisible(object)
          })


##' @rdname show-method
##' @aliases show,mcf.rateReg-method
##' @export
setMethod(
    f = "show",
    signature = "mcf.rateReg",
    definition = function(object) {
        cat("Formula:\n")
        print(object@formula)
        cat("\nNew data:\n")
        print(object@newdata)
        cat("\nConfidence level:",
            paste(format(100 * object@level,
                         trim = TRUE, scientific = FALSE),
                  "%", sep = ""), "\n")
        cat("\nMCF:\n")
        print(object@MCF)
        ## invisible return
        invisible(object)
    }
)


##' @rdname show-method
##' @aliases show,simEvent-method
##' @export
setMethod(
    f = "show",
    signature = "simEvent",
    definition = function(object) {
        cat("'simEvent' S4 class object:\n")
        print(object@.Data)
        ## invisible return
        invisible(object)
    }
)


##' @rdname show-method
##' @aliases show,mcfDiff-method
##' @export
setMethod(
    f = "show",
    signature = "mcfDiff",
    definition = function(object) {
        cat("Call: \n")
        print(object@call)
        if (object@test@testVariance != "none") {
            cat("\nTwo-Sample Pseudo-Score Tests:\n")
            printCoefmat(object@test@.Data)
            cat("\nVariance Estimator:", object@test@testVariance, "\n")
        }
        ## invisible return
        invisible(object)
    }
)


##' @rdname show-method
##' @aliases show,mcfDiff.test-method
##' @export
setMethod(
    f = "show",
    signature = "mcfDiff.test",
    definition = function(object) {
        cat("Two-Sample Pseudo-Score Tests:\n")
        printCoefmat(object@.Data)
        cat("\nVariance Estimator:", object@testVariance, "\n")
        ## invisible return
        invisible(object)
    })
